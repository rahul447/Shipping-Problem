{"version":3,"sources":["../../../lib/endpoints/services/cloudTravel.es6"],"names":["cloudTravel","latArr","longArr","canTravelArr","start","dest","earthRadius","lat1","lat2","lon1","lon2","Math","acos","sin","cos","currentAirport","currTravelPath","canTravelMap","get","indexOf","milesTraveled","split","map","route","distanceMap","canTravelAirport","traverseCanTravelMap","Map","key","value","routeDistance","calcArcLength","set","Promise","resolve","reject","validateConstraints","then","data","startArr","length","calcTravelDistanceForAllRoutes","catch","err","latLongMap","val","inRange","modObj","lat","long","airPortArr","innerval","parseInt","push"],"mappings":"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","file":"cloudTravel.js","sourcesContent":["\"use strict\";\nimport _ from \"lodash\";\n\nexport class cloudTravel {\n\n    constructor(latArr, longArr, canTravelArr, start, dest) {\n        this.earthRadius = 4000;\n        this.latArr = latArr;\n        this.longArr = longArr;\n        this.canTravelArr = canTravelArr;\n        this.start = start;\n        this.dest = dest;\n    }\n\n    // returns distance b/w 2 airports as per formula\n    calcArcLength(lat1, lat2, lon1, lon2) {\n\n        return this.earthRadius * Math.acos(Math.sin(lat1) * Math.sin(lat2) +\n                Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));\n    }\n\n    // traverse canTravelMap, calculates Miles Traveled\n    traverseCanTravelMap(currentAirport, currTravelPath) {\n\n        // only TRUE when dest airport is found\n        if(this.canTravelMap.get(currentAirport).indexOf(this.dest) > -1) {\n\n            // so for usecase 1 as per doc, currTravelPath = \"0=>2,2=>1\"\n            currTravelPath += \"=>\" + this.dest + \",\";\n\n            let milesTraveled = 0.0;\n\n            currTravelPath.split(\",\").map((route) => {\n                if(route) {\n                    milesTraveled += this.distanceMap.get(route);\n                }\n            });\n\n            this.milesTraveled = milesTraveled;     //total miles traveled for each use case\n\n        }else {\n\n            this.canTravelMap.get(currentAirport).map((canTravelAirport) => {\n                currTravelPath += \"=>\" + canTravelAirport + \",\" + canTravelAirport;\n\n                // recursion\n                this.traverseCanTravelMap(canTravelAirport, currTravelPath);\n            });\n        }\n    }\n\n    // calculates distance between all routes found in each use case (canTravelMap)\n    // Eg in case of { 0 => [ 2 ], 1 => [ 0, 2 ], 2 => [ 0, 1 ] }\n    // routes will be 0 to 2, 1 to 0, 1 to 2, 2 to 0, 2 to 1\n    calcTravelDistanceForAllRoutes() {\n\n        let distanceMap = new Map();\n\n        for (let [key, value] of this.canTravelMap) {\n\n            value.map((canTravelAirport) => {\n\n                let routeDistance = this.calcArcLength(this.latArr[key],\n                    this.latArr[canTravelAirport], this.longArr[key],\n                    this.longArr[canTravelAirport]);\n\n                distanceMap.set(key + \"=>\" + canTravelAirport, routeDistance)\n            });\n        }\n\n        return distanceMap;\n    }\n\n    // main method\n    shortestCourierTrip() {\n\n        return new Promise((resolve,reject) => {\n\n            this.validateConstraints().then((data) => {\n\n                let startArr = data.canTravelMap.get(this.start);\n\n                // check for -1 route not found\n                // when data.canTravelMap has values like  { 0 => [ 2 ], 2 => [ 0 ] }\n                if(startArr.length === 1 && data.canTravelMap.get(startArr[0]).length === 1\n                    && data.canTravelMap.get(startArr[0])[0] === this.start) {\n\n                    resolve(-1);    // route not found\n\n                } else if(this.start === this.dest) {\n                    resolve(0.0);       // start airport same as dest airport\n                } else {\n                    this.canTravelMap = data.canTravelMap;\n                    this.distanceMap = this.calcTravelDistanceForAllRoutes();\n\n                    let currTravelPath = this.start;\n\n                    // as this method is call recursively ,\n                    // 1st param denotes current airport,2nd param denotes current traveled path\n                    this.traverseCanTravelMap(this.start, currTravelPath);\n\n                    resolve(this.milesTraveled);\n                }\n\n            }).catch(err => {\n                reject(err);\n            });\n        });\n    }\n\n    // validate constraints on lat, long, canTravel\n    validateConstraints() {\n\n        return new Promise((resolve, reject) => {\n\n            // check constraint 2 as per doc\n            if(!(this.latArr.length === this.longArr.length ||\n                this.latArr.length === this.canTravelArr.length)) {\n\n                reject(\"cloudTravel.validate()// \" +\n                    \"Length of latArr, longArr, canTravelArr not Equal\");\n\n            } else if(this.latArr.length > 20 || this.longArr.length > 20\n                || this.canTravelArr.length > 20) {     // check constraint 1 as per doc\n\n                reject(\"cloudTravel.validate()// \" +\n                    \"Length of latArr or longArr or canTravelArr > 20\");\n\n            }else {\n\n                let latLongMap = new Map(),\n                    canTravelMap = new Map();\n\n                this.latArr.map((val, key) => {\n\n                    // check constraint 3 as per doc\n                    if(!_.inRange(val, -89, 90)) {\n                        reject(\"cloudTravel.validate()// \" + \"Lat val not valid\");\n                    }\n\n                    latLongMap.set(key, {\"lat\": val});\n\n                });\n\n                this.longArr.map((val, key) => {\n\n                    // check constraint 4 as per doc\n                    if(!_.inRange(val, -179, 180)) {\n                        reject(\"cloudTravel.validate()// \" + \"Long val not valid\");\n                    }\n\n                    let modObj = latLongMap.get(key);\n\n                    for (let [, value] of latLongMap) {\n\n                        // check constraint 8 as per doc\n                        if(modObj.lat === value.lat && val === value.long) {\n                            reject(\"cloudTravel.validate()// \" +\n                                \"Same Lat long not allowed for two airports\");\n                        }\n                    }\n\n                    modObj.long = val;\n                });\n\n                this.canTravelArr.map((val, key) => {\n\n                    let airPortArr = [];\n\n                    val.split(\" \").map((innerval) => {\n\n                        // check constraint 6 as per doc\n                        if(!(_.inRange(parseInt(innerval), 0, this.latArr.length))) {\n                            reject(\"cloudTravel.validate()// \" + \"canTravelArr val not valid\");\n                        }\n\n                        airPortArr.push(parseInt(innerval));\n                    });\n\n                    canTravelMap.set(key, airPortArr);\n                });\n\n                // check constraint 7 as per doc\n                if(!(_.inRange(this.start, 0, this.latArr.length)\n                    || _.inRange(this.dest, 0, this.latArr.length))) {\n                    reject(\"cloudTravel.validate()// \" + \"start or dest val not valid\");\n                }\n\n                resolve({latLongMap, canTravelMap});\n            }\n        });\n    }\n}\n"]}